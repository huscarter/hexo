---
title: 常用设计模式整理
date: 2020-08-01 20:18:44
categories: 设计模式
tags:
     - 设计模式
description: 设计模式介绍。
---

## 创建型模型

### 单例（包含5种实现方式）

#### 饿汉模式（调用效率高，但是不能延时加载）
```
// 饿汉式非常“饿” 上来就直接new一个对象 不管后面会不会用到
private static HungerySingleton h = new HungerySingleton();

// 私有构造器
private HungerySingleton() {};

// 供外部拿到该对象
public static HungerySingleton getInstance() {return h;}
```

#### 懒汉模式（调用效率不高，但是可以延时加载）
```
// 懒汉式一开始不会初始化，等到用的时候初始化
private static LazySingleton instance;

// 私有构造器
private LazySingleton() {};

// 需要添加synchronized，方法同步调用效低
public static synchronized LazySingleton getInstance() {
    if (instance == null) {
        instance = new LazySingleton();
    }
    return instance;
}
```

#### 双重检测锁式(由于JVM底层内部模型原因，偶尔会出现问题，不建议使用)
```
private static DoubleCheckSingleton instance = null;
 
// 私有化构造器
private DoubleCheckSingleton() {};

public static DoubleCheckSingleton getInstance() {
    if (instance == null){
        synchronized(Singleton.class) {
            if (instance == null) instance = new Singleton();
        }
    }
    return instance;
}
```

#### 静态内部类式（调用效率高，可以延时加载）
```
// 私有化构造器
private StaticClassSingleton() {};

// 静态内部类
private static class StaticClassSingletonInstance {
    private static final StaticClassSingleton instance = new StaticClassSingleton();
}

public static StaticClassSingleton getInstance() {
    return StaticClassSingletonInstance.instance;
}
```
#### 枚举单例（调用效率高，不能延时加载）
```
public enum EnumSingleton {
    // 这个枚举元素本身就是单例的
    INSTANCE;
 
    // 添加自己的操作
    public void singletonOperation() {
 
    }
}
```

### 构造器

### 原型模式

### 工厂模式
#### 简单工厂（静态工厂模式）
为了避免过多的依赖，通过调用不同生产方法得到同一接口下的不用实例，缺点是不改变工厂类代码不能新增产品。以下为举例：
1. 普通接口实现
```
public static void main(String[] args) {
    Car c1 = new Audi();
    Car c2 = new Byd();
    
    c1.run();
    c2.run();
}
```
2. 简单工厂实现
```
public static void main(String[] args) {
    Car c1 = CarFactory.createCar("奥迪"); // createAudi()
    Car c2 = CarFactory.createCar("比亚迪"); // createByd()

    c1.run();
    c2.run();
}
```

#### 工厂方法模式
工厂方法模式会有一个总的工厂接口，然后为每一个类创建一个工厂，支持新增产品。(设计复杂度还是管理难度上面都要劣于简单工厂模式,建议使用简单工厂模式)
```
public interface CarFactory {
    Car createCar();
}
public class AudiFactory implements CarFactory {
    @Override
    public Car createCar() {return new Audi();}
}
public class BydFactory implements CarFactory {
    @Override
    public Car createCar() {return new Byd();}
}　　
```

#### 抽象工厂
区别其他工厂模式，此模式是生成不同级别的产品；将产品功能进行接口抽象后，提供一个总的抽象工厂类，之后提供各级别工厂类来生产实例。
```
// 总的抽象工厂类
public interface CarFactory {
    Engine createEngine(); // 创建引擎的接口
    Seat createSeat();// 创建座位的接口
    Tyre createTyre();// 创建轮胎的接口
}
// 生成高级车的工厂类
public class LuxuryCarFactory implements CarFactory {
    @Override
    public Engine createEngine() {
        return new LuxuryEngine();
    }
 
    @Override
    public Seat createSeat() {
        return new LuxurySeat();
    }
 
    @Override
    public Tyre createTyre() {
        return new LuxuryTyre();
    }
}
// 生成低级车的工厂类
public class LowCarFactory implements CarFactory {
    @Override
    public Engine createEngine() {
        return new LowEngine();
    }
 
    @Override
    public Seat createSeat() {
        return new LowSeat();
    }
 
    @Override
    public Tyre createTyre() {
        return new LowTyre();
    }
}

```

## 结构型模式
### 适配器模式

### 桥接模式

### 装饰模式

### 组合模式

### 外观模式

### 享元模式

### 代理模式

## 行为型模式
### 模板方法模式

### 命令模式

### 迭代器模式

### 观察者模式

### 中介者模式

### 备忘录模式

### 解释器模式

### 状态模式

### 策略模式

### 职责链模式

### 访问者模式








